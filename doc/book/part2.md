# Part 2: Album list middleware

In this part of the tutorial we will setup a new middleware to show the 
album list. This album list middleware will only be setup but it will not
show any data yet.

## Setup album list middleware

First, we will need to setup a new middleware for the album list. You will
need to create the new path `/src/Album/Action/` and place a new 
`AlbumListAction.php` file within this new path.

```php
<?php
namespace Album\Action;

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Zend\Diactoros\Response\HtmlResponse;
use Zend\Expressive\Template\TemplateRendererInterface;

/**
 * Class AlbumListAction
 *
 * @package Album\Action
 */
class AlbumListAction
{
    /**
     * @var TemplateRendererInterface
     */
    private $template;

    /**
     * @param TemplateRendererInterface|null $template
     */
    public function __construct(
        TemplateRendererInterface $template = null
    ) {
        $this->template = $template;
    }

    /**
     * @param ServerRequestInterface $request
     * @param ResponseInterface      $response
     * @param callable|null          $next
     *
     * @return HtmlResponse
     */
    public function __invoke(
        ServerRequestInterface $request, ResponseInterface $response,
        callable $next = null
    ) {
        $data = [];

        return new HtmlResponse(
            $this->template->render('album::list', $data)
        );
    }
}
```

Since the `AlbumListAction` needs to render a template it has a dependency
to the template renderer. The renderer can be injected into the constructor
of the `AlbumListAction` class. Within the `__invoke()` method a 
`HtmlResponse` is created and returned. The injected template renderer is
used to render the album list template. Since we have no data to output 
yet, an empty array is passed to the renderer.

A few words about the used namespaces, interfaces and classes.

* The `Psr\Http\Message` package contains a set of standardized HTTP 
  message interfaces which are also known as 
  [PSR-7](http://www.php-fig.org/psr/psr-7/). A lot of PHP frameworks
  and open source projects implement these interfaces within their 
  projects.
  
* The component [`Zend\Diactoros`](https://github.com/zendframework/zend-diactoros) 
  contains the Zend Framework specific implementations of the mentioned 
  PSR-7 HTTP message interfaces. 
  
* The `HtmlResponse` allows to create responses with HTML strings. By 
  default these responses have a 200 HTTP status code and a content-type
  set to `text/html`. 

* Note that the `HtmlResponse` class accepts a status code and headers as
  additional arguments. To output the status code and response headers 
  generated by middleware executed with a higher priority you need to pass 
  them manually to the `HtmlResponse`.

```php
return new HtmlResponse(
    $this->template->render('album::list', $data),
    $response->getStatusCode(), 
    $response->getHeaders()
);
```

## Setup factory for album list middleware

To work properly, the `AlbumListAction` needs a factory to inject the
template renderer. Please create a `AlbumListActionFactory.php` file within 
the same path of the `AlbumListAction` class. 

```php
<?php
namespace Album\Action;

use Interop\Container\ContainerInterface;
use Zend\Expressive\Template\TemplateRendererInterface;

/**
 * Class AlbumListFactory
 *
 * @package Album\Action
 */
class AlbumListFactory
{
    /**
     * @param ContainerInterface $container
     *
     * @return AlbumListAction
     */
    public function __invoke(ContainerInterface $container)
    {
        $template = $container->get(TemplateRendererInterface::class);

        return new AlbumListAction($template);
    }
}
```

Within the `__invoke()` method of this factory the instance of the 
template renderer is requested from the DI container by using its class
name. This template renderer instance is injected into the constructor of
the `AlbumListAction` class which is returned by the factory.

The used [`Interop\Container\ContainerInterface`](https://github.com/container-interop/container-interop) 
is a package which tries to standardize features in container objects 
(service locators, dependency injection containers, etc.) to achieve 
interoperability.

With this factory the `AlbumListAction` can be instantiated by using its 
own factory.

## Setup template for album list

In the next step we need a template file for the album list. Please create
the new path `/templates/album/` and place a new `list.phtml` file within 
this new path.

```php
<?php $this->headTitle('Albums'); ?>

<div class="jumbotron">
    <h1>Album list</h1>
</div>
```

This template sets the title of the page and prints the heading within a
div that is styled by [Bootstrap](http://getbootstrap.com/). Please note, 
that there is no echo needed for the `$this->headTitle()` call since the
output of the page title is done within the layout file 
`/templates/layout/default.phtml`.

## Setup configuration for album

Currently, our `Zend\Expressive` application has no idea of the new action
and the template and does not know when to process it. So we need to add
a little bit of configuration.

Please create a new `album.global.php` file in the `/config/autoload` 
path.

```php
<?php
return [
    'dependencies' => [
        'factories' => [
            Album\Action\AlbumListAction::class =>
                Album\Action\AlbumListFactory::class,
        ],
    ],

    'routes' => [
        [
            'name' => 'album',
            'path' => '/album',
            'middleware' => Album\Action\AlbumListAction::class,
            'allowed_methods' => ['GET'],
        ],
    ],

    'templates' => [
        'paths' => [
            'album'    => ['templates/album'],
        ],
    ],
];
```

* Within the `dependencies` configuration section you can configure the
  DI container (the `Zend\ServiceManager` in our project). We use the
  class name of the new `AlbumListAction` as the identifier and the 
  `AlbumListFactory` as the factory to be processed, whenever the action
  is requested from the DI container.

* Within the `routes` configuration section you can configure a route to 
  process a middleware. This route is defined by the name "`album`". It 
  defines the path `/album` and defines our new `AlbumListAction` 
  middleware to be processed whenever a request matches with the configured
  path. It also restricts the access and only allows GET requests for this
  route.
  
* Within the `templates` configuration section you can configure the paths
  for the templates. We have added the new `/templates/album/` passed to 
  the configuration. 

## Update composer.json for autoloading

To finish the setup we need to configure the autoloading for our new
classes. This can be done in the `composer.json` file. You just need to add 
the `Album\` namespace with its path to the `autoload` section of the 
`composer.json` file.

```
{
    // ... 

    "autoload": {
        "psr-4": {
            "App\\": "src/App/",
            "Album\\": "src/Album/"
        }
    },

    // ... 
}
```

Now you need to do a composer update to create the autoloading:

```
$ composer update
```

## Add link to default layout

Finally, we need to add a link to the new page within the menu. Please open
the `/templates/layout/default.phtml` file and add the link to the album 
list by using the name of the route we configured earlier.

```
<body class="app">
    <header class="app-header">
        <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
            <div class="container">
                <!-- ... -->
                <div class="collapse navbar-collapse">
                    <ul class="nav navbar-nav">
                        <!-- ... -->
                        <li>
                            <a href="<?php echo $this->url('album') ?>">
                                <i class="fa fa-music"></i> Album
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
    </header>
    <!-- ... -->
</body>
```

## Watch album list in browser

Now you can browse to 
[http://localhost:8080/album](http://localhost:8080/album) to see if the 
album page was setup properly. 

![Screenshot of album list with no data](images/screen-album-list-no-data.png)

## Setup PHPUnit for testing album list middleware

Setting up (PHPUnit)[https://phpunit.de/] for testing is quite simple. 
Just copy the `phpunit.xml.dist` file in the project root to 'phpunit.xml' 
and add the album test directory to the test suite.

```xml
<phpunit bootstrap="./vendor/autoload.php" colors="true">
    <testsuites>
        <testsuite name="App\\Tests">
            <directory>./test/AppTest</directory>
        </testsuite>
        <testsuite name="Album\\Tests">
            <directory>./test/AlbumTest</directory>
        </testsuite>
    </testsuites>

    <filter>
        <whitelist processUncoveredFilesFromWhitelist="true">
            <directory suffix=".php">src</directory>
        </whitelist>
    </filter>
</phpunit>
```

## Setup tests for album list middleware

You need to create the `/test/AlbumTest/Action/` path and add the file
`AlbumListActionTest.php` to this new path. This test case should test the
action we just created. The `AlbumListActionTest` tests if the 
`AlbumListAction` returns an instance of 
`Zend\Diactoros\Response\HtmlResponse` which has some rendered content. 

```php
<?php
namespace AlbumTest\Action;

use Album\Action\AlbumListAction;
use PHPUnit_Framework_TestCase;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Zend\Diactoros\Response\HtmlResponse;
use Zend\Expressive\Template\TemplateRendererInterface;

/**
 * Class AlbumListActionTest
 *
 * @package AlbumTest\Action
 */
class AlbumListActionTest extends PHPUnit_Framework_TestCase
{
    /**
     * @var ServerRequestInterface
     */
    private $request;

    /**
     * @var ResponseInterface
     */
    private $response;

    /**
     * @var callable
     */
    private $next;

    /**
     * Setup test case
     */
    public function setUp()
    {
        $this->request  = $this->prophesize(ServerRequestInterface::class);
        $this->response = $this->prophesize(ResponseInterface::class);

        $this->next = function () {
        };
    }

    /**
     * Test if action renders the album list
     */
    public function testActionRendersAlbumList()
    {
        $renderer = $this->prophesize(TemplateRendererInterface::class);
        $renderer->render('album::list', [])->shouldBeCalled()->willReturn(
            'BODY'
        );

        $action = new AlbumListAction($renderer->reveal());

        $response = $action(
            $this->request->reveal(),
            $this->response->reveal(),
            $this->next
        );

        $this->assertInstanceOf(HtmlResponse::class, $response);

        $this->assertEquals('BODY', $response->getBody());
    }
}
```

Create another test for the factory in the same path. The 
`AlbumListFactoryTest` tests if the `AlbumListFactory` returns an instance
of the `AlbumListAction`.

```php
<?php

namespace AppTest\Action;

use Album\Action\AlbumListAction;
use Album\Action\AlbumListFactory;
use Interop\Container\ContainerInterface;
use Zend\Expressive\Router\RouterInterface;
use Zend\Expressive\Template\TemplateRendererInterface;

/**
 * Class AlbumListFactoryTest
 *
 * @package AppTest\Action
 */
class AlbumListFactoryTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var ContainerInterface
     */
    protected $container;

    /**
     * Setup test case
     */
    protected function setUp()
    {
        $this->container = $this->prophesize(ContainerInterface::class);
        $router          = $this->prophesize(RouterInterface::class);

        $this->container->get(RouterInterface::class)->willReturn($router);
    }

    /**
     * Test if factory returns the correct action
     */
    public function testFactory()
    {
        $this->container
            ->get(TemplateRendererInterface::class)
            ->willReturn(
                $this->prophesize(TemplateRendererInterface::class)
            );

        $factory = new AlbumListFactory();

        $this->assertTrue($factory instanceof AlbumListFactory);

        $action = $factory($this->container->reveal());

        $this->assertTrue($action instanceof AlbumListAction);
    }
}
```

To run the tests simple run this command:

```
$ phpunit
```

## Compare with example repository branch `part2`

You can easily compare your code with the example repository when looking 
at the branch `part2`. If you want you can even clone it and have a deeper
look.

[https://github.com/RalfEggert/zend-expressive-tutorial/tree/part2](https://github.com/RalfEggert/zend-expressive-tutorial/tree/part2)
